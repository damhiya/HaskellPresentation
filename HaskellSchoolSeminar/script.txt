#1 ST 모나드와 다형성
  안녕하세요 ST 모나드와 다형성이란 주제로 발표를 맞게된 문순원입니다.
  제 발표는 하스켈을 확장한 타입시스템에 대해 이야기하는 상당히 어려운 주제입니다.
  선행지식이 없다면 완전한 이해는 어려울 수 있지만, 단편적인 지식이라도 얻어가셨으면 좋겠습니다.

#2 ST 모나드의 필요
  일반적인 프로그래밍에는 가변자료형이 자주 사용되는데요,
  예를들어서 퀵정렬과 같은 배열을 다루는 알고리즘은 가변자료형이 없다면 효율적으로 구현하기 힘듭니다.
  하스켈은 순수함수형 언어이기때문에 기본적으로 가변자료의 사용을 금지하지만,
  IO모나드를 통해 제한적으로 가변성을 허용합니다.
  즉 하스켈에서 가변자료형을 사용하고 싶다면 IO모나드의 사용이 필수적입니다.
  
  문제는, IO모나드는 외부와의 상호작용과 같이 가변성 이상의 기능을 제공한다는 점입니다.
  또 IO모나드의 연산결과는 IO모나드를 탈출할 수 없는데, 이는 IO모나드의 연산결과를 IO모나드 안에서만 사용할 수 있다는 뜻입니다.
  만약 unsafePerformIO등을 사용해 IO모나드의 연산결과를 강제로 탈출시키면 참조 투명성을 훼손할 수 있습니다.

#3 ST 모나드의 개선점
  ST모나드는 IO모나드의 이러한 단점을 해결한 대안입니다.

  ST 모나드는 외부와의 상호작용을 허용하지 않으므로 결정론적이며,
  ST 모나드를 안전하게 탈출할 수 있는 인터페이스를 제공합니다.
  따라서 ST 모나드를 사용하면 가변자료형을 사용하면서도 순수 함수 인터페이스를 가진 코드를 작성할 수 있습니다.
  (가변자료를 사용한다는 말이 곧 명령형 코드를 사용한다는 뜻이죠)
  
#4 어떻게 가능한가?
  ST모나드로 이런일을 가능하게 하는 핵심적 요소는 runST 함수인데요.
  runST는 ST모나드의 연산결과를 ST모나드에서 탈출시키는 함수이며
  이를 위해 rank-2 다형성이라는 개념을 활용합니다.

#5 다형함수를 인자로 받기
  rank-2 다형성을 설명하기 위해서 다음의 코드를 준비했습니다.
  이 코드에서 bar는 foo에 인자로 id를 전달합니다.
  foo는 인자로 받은 함수 f에 1과 True를 인자로 적용합니다.
  1은 Int타입이고 True는 Bool타입이기 때문에 함수 f는 다형함수 여야만 합니다.
  f = id 라고 생각하시면 자연스럽게 이해하실수 있을것 같습니다.

  이때 id함수의 타입은 임의의 a에 대해서 a에서 a로 가는 함수타입인데요,
  이 id를 인자로 받는 foo의 타입은 다음과 같이 됩니다.
  이는 rank-2 타입의 예시인데, 표준하스켈에서는 이런 타입을 허용하지 않습니다.

#6 rank에 따른 타입의 분류
  방금은 rank-2 타입을 예시로만 보여드렸기 때문에,
  rank의 정의를 이야기해 드리겠습니다.
  rank는 universal quantifier의 위치가 contravariant하게 중첩되는 깊이를 나타내는데요,
  여기서 universal quantifier는 forall 키워드를 말하고, contravariant는 함수타입의 왼편을 말합니다. 함수타입의 오른편은 covariant라고 표현합니다.

  먼저 rank-0 타입은 단형 타입으로, forall 키워드가 나타나지 않는 경우를 말합니다.

  다음으로 rank-1타입은 일반적인 하스켈의 다형타입처럼 forall이 타입의 맨 바깥쪽에 위치하는 타입이나
  두번째 예시처럼 함수타입 화살표의 오른쪽에 forall이 나타나는 경우를 말합니다.
  여기서 예시로 든 두 타입은 사실 서로 동등한데요, currying된 2변수 함수의 인자 순서를 교환하는것을 생각하시면 됩니다.

  rank-2 타입은 이전 슬라이드에서 본 예시와 같이 forall 키워드가 화살표의 왼쪽에 나타나는 경우를 말합니다.

  이 forall이 화살표의 왼쪽에 위치하는 횟수가 한번더 중첩되면 다음과 같은 rank-3 타입이 됩니다.
  마찬가지로 contravariant한 깊이가 깊어지면 rank가 계속 올라가게 됩니다.

  표준 하스켈의 타입 시스템은 Hindley-Milner 타입 시스템에 기반하는데요
  이 HM 타입시스템은 : rank-0타입이나 forall키워드가 타입의 맨 바깥쪽에 위치하는 rank-1타입만을 허용합니다.
  Hindley-Milner 타입 시스템이 rank-1 까지만 허용하는것은 rank-2 이상에서 타입추론이 어렵기 때문입니다.
 
#7 rank에 따른 타입시스템의 분류
  이 타입의 랭크를 허용하는 정도에 따라서 타입시스템을 분류할 수 있는데요,
  rank-1 이하의 타입을 허용하는 타입시스템을 rank-1 다형성을 가진다고 말하고
  rank-2 이하라면 rank-2 다형성
  일반적으로 rank-k 이하의 타입을 허용하면 rank-k 다형성이라고 부릅니다.
  
  그리고 랭크에 제한이 없어 임의의 랭크를 가진 타입을 허용하면 rank-n 혹은 higher rank 다형성이라고 부릅니다.
  
  한편 타입추론은 rank-2 다형성 타입 시스템 까지만 결정가능한데,
  타입 추론이 결정가능하지 않으면 타입 시그니쳐를 직접 적어줘야 합니다.

#8 GHC의 언어 확장 RankNTypes
  RankNTypes는 ghc에서 higher rank 다형성을 허용하게 해주는 언어확장입니다.
  이 확장을 사용하면 아까 보았던 다음과 같은 코드를 작성할 수 있게 됩니다.

  아까 말했듯이 랭크 2 다형성에서 타입추론은 이론적으로 결정가능한데요,
  이를 실제로 구현하기는 대단히 복잡하기 때문에 GHC에서는 결정가능한 rank-2타입 추론이 구현된적이 없습니다.
  실제로 Rank2Types는 RankNTypes로 작동하게 되어있으니 그냥 RankNTypes를 쓰시면 됩니다.

#9 rank vs kind
  rank는 아까말했듯이 타입을 분류하는 기준인데요, kind 또한 일종의 타입을 분류하는 개념이지만 rank와는 전혀 다릅니다.
  이건 아까 보여드렸던 4가지 예시 타입인데요, 이 타입들의 rank는 각각 rank-0, rank-1, rank-1. rank-2 로 분류되지만
  kind로는 rank에 상관없이 모두 'Type' 이라는 kind에 속합니다.
  즉 모두 같은 범주에 속하는 타입들이므로 모두 똑같이 취급되기를 기대하는데요,
  실제 하스켈에서는 rank에 따라서 타입의 취급이 달라집니다.

  그래서 다형타입은 일급시민이 아니라고 표현을 하죠.  

#10 Impredicativity
  왜 이런차이가 생기는지 자세히 보여드리겠습니다.
  여기 id, mono, poly 라는 3개의 함수가 있는데요, id는 흔히아는 항등함수이고
  mono와 poly함수는 리스트를 뒤집는 reverse함수를 상상하시면 되겠습니다.
  reverse함수를 Bool타입에 대해서 특화시키면 mono함수가 되겠죠?
  
  id, mono, poly를 사용해서 mono_a, poly_a, poly_b 3개함수를 정의했는데요
  골뱅이 표시는 type application을 나타내는 문법입니다. 일종의 슈도 하스켈 코드라고 생각하셔도 됩니다.
  type application 문법을 제거하고 보면 그냥 mono나 poly함수를 id함수의 인자로 적용하는 코드가 됩니다.

  먼저 mono_a의 경우에는 
  id의 타입변수 p를 불의 리스트에서 불의 리스트로 가는 함수 타입으로 인스턴스화 합니다.

  poly_a의 경우에는
  타입변수 b를 인자로 받아서 p를 b의 리스트에서 b의 리스트로 가는 함수,
  a를 b로 인스턴스화 하죠.

  그리고 poly_b함수의 경우에는
  타입변수 p를 임의의 a에 대해 a의 리스트에서 a의 리스트로 가는 함수 타입으로 인스턴스화 하는데요

  즉 poly_b의 경우, 타입 변수를 다형 타입으로 인스턴스화 한다는 점에서 mono_a나 poly_a와 구분됩니다.
  이렇게 타입변수를 다형타입으로 인스턴스화 하는것을 impredicative 다형성이라고 부르는데요,
  impredicative 다형성은 rank-n 다형성의 일반화라고 볼수 있습니다.
  예를들어서 원소로 id를 가지는 리스트의 타입은 리스트 타입 생성자 안에 forall 키워드가 나타나는데요
  아까 rank-n 타입이 forall 키워드가 함수 타입 생성자 안에 나타날수 있게 했던것처럼
  impredicative 타입은 forall 키워드가 임의의 타입생성자 안에 나타날수 있게 합니다.

  GHC는 아직 impredicativity를 지원하지 않지만, Quick Look Impredicativity 라는 타입추론 방식을 개발중이구요,
  이게 구현되면 GHC에서 impredicative 타입을 사용할 수 있게 됩니다.

#11 ST & runST
  다시 ST모나드 이야기로 돌아가겠습니다.
  먼저 ST action은 ST s a 꼴 타입을 가지는데, 이건 s 라는 스레드에서 연산을 해서 a타입의 결과를 만들어내는 프로시저의 타입이라고 생각하시면 됩니다.
  여기서 s는 어떤 구체적인 타입으로 인스턴스화 되는것이 아니라 타입변수로만 존재하기 때문에, 일종의 트릭이라고 생각하셔도 됩니다.
  아까 말씀드렸다시피 runST는 ST모나드의 연산결과를 ST모나드 밖으로 탈출시키는데,
  이때 내부상태는 ST모나드를 탈출할 수 없습니다.

#12 ST 모나드의 내부 상태
  여기서 말하는 내부상태라는건 곧 가변상태를 말하는데.
  ST 모나드에서 내부상태는 참조 변수를 통해서 관리됩니다.
  참조 변수에는 STRef, MVector, HashTable 같은것들이 있는데요,
  이름에서 나타나는것처럼 각각 레퍼런스, 벡터, 해시테이블을 다루는 참조 변수구요,
  타입변수 s와 a는 이 타입들이 스레드 s에 종속되어 있고, a타입의 값을 다룸을 의미합니다.
  
  참조 변수들은 ST모나드 안에서 값을 읽고 쓸수 있는데
  예를들어서 newSTRef는 새로운 STRef를 할당하는 함수구요,
  readSTRef는 ST모나드 안에서 STRef의 값을 읽는 함수,
  writeSTRef는 ST모나드 안에서 STRef에 값을 쓰는 함수입니다.
  MVector나 HashTable도 이와 비슷한 함수들을 사용해서 참조가 가리키는 가변 상태를 조작할 수 있습니다.

#13 runST의 참조투명성 보장
  이제 runST가 어떻게 내부상태가 유출되는것을 방지하는지 보여드릴건데요,
  action은 ST 모나드 안에서 새로운 STRef를 만들고, 그 STRef의 값을 읽어서 리턴하구요,
  escapeInt는 이 action을 runST를 사용해 실행합니다.
  여기서 runST가 인자로 받는 타입 forall s. ST s a 타입과 runST가 인자로 받은 action의 타입
  forall s. ST s Int 가 동일하다는 타입 방정식을 풀면
  a와 Int가 같다는 결과를 얻고, 이건 문제없이 컴파일 됩니다.
  이경우에서 보이는것처럼 Int타입은 ST모나드를 문제없이 탈출할 수 있습니다.

  한편 escapeSTRef의 action은
  새 STRef를 만들어서 이 STRef자체를 리턴하는데요,
  이 경우 타입방정식을 풀면 a와 STRef s Int가 같다는 결론을 얻게됩니다.
  그런데, 타입변수 a는 타입변수 s바깥의 스코프에서 정의되었기 때문에, a 가 STRef s Int 가 된다면
  타입변수 s가 s가 정의된 스코프 바깥에서 사용되게 됩니다.
  따라서 이경우 타입 에러가 되고, 컴파일이 실패합니다.
  즉 STRef s Int는 ST모나드를 탈출할수 없는거죠.
  일반적으로 타입변수 s로 마킹된 타입은 ST 모나드를 탈출할 수 없게 됩니다.
  즉 내부상태를 가리키는 모든 참조 타입들을 타입변수 s로 마킹하면 내부상태가 ST모나드를 탈출하지 못하게 활수 있는거죠.

#14 ST 모나드와 벡터
  한편 하스켈에서 벡터타입은 가변벡터인 MVector와 불변벡터인 Vector타입이 있는데요,
  이 둘간의 변환을 위해서 일반적으로 freeze와 thaw를 사용하게 됩니다.
  freeze와 thaw는 기존 벡터를 복사해 새로운 불변혹은 가변 벡터를 만듭니다.
  
  당연히 벡터를 통채로 복사하는것은 굉장히 비효율적인데,
  그래서 이를 피하기 위해 복사를 하지 않는 unsafeFreeze와 unsafeThaw가 있습니다.
  
  문제는 이 unsafe함수들은 타입 시스템을 우회해서 참조 투명성을 깨뜨릴 수 있기 때문에,
  프로그래머가 안전성을 검증해야 합니다.

  다행인점은, unsafeFreeze 와 runST를 조합하면 create 함수를 얻을수 있는데
  create의 내부 구현은 unsafeFreeze를 사용하지만, create 함수 자체는 항상 안전합니다.
  즉 create함수는 복사가 없으면서도 항상 참조투명성을 보장해줍니다.
  다만 create함수는 freeze/thaw의 모든 사용처를 대체할수 없습니다.
  
#15 create 사용 예시 (병합 정렬)
  create의 사용예시를 보여드리겠습니다.
  이건 ST모나드와 벡터를 사용한 병합 정렬 구현인데, github gist에 전체 소스가 공개되있습니다.

  먼저 sortM 은 인자로 받은 가변 벡터를 정렬하는 함수입니다.
  그리고 sort는 불변벡터를 인자로 받아서, 이를 복사한뒤 정렬된 불변벡터로 반환합니다.

  먼저 기본 구현은 freeze를 사용하는데요, 아까 말했다시피 이 경우 freeze에서 벡터를 통채로 복사합니다.
  그래서 이를 unsafeFreeze대체할수 있는데요,
  이 경우 unsafeFreeze함수를 올바르게 사용했기 때문에 문제가 발생하지 않지만,
  unsafe함수를 사용할때마다 프로그래머가 주의를 기울이는것은 상당히 피곤한 일입니다.
  다행히도 이 경우, unsafeFreeze와 runST함수를 합쳐서 create함수로 대체할수 있는데요
  이렇게 구현하면 불필요한 복사를 하지 않으며 참조투명성이 깨질 걱정도 없는것이죠

#16 Q&A
  발표를 들어주셔서 감사합니다.
  지금부터 질문을 받도록 하겠습니다.
